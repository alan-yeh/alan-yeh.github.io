<!DOCTYPE html>
<html>
<head>
    <!-- [[! Document Settings ]] -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- [[! Page Meta ]] -->
    <title>PSPromise Promise的简易实现</title>
    <meta name="description" content="Alan Yeh - 写写代码，想想东西，程序员的世界可以就这么简单。" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="/assets/images/favicon.ico" >

    <!-- [[! Styles'n'Scripts ]] -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
<!--
    <link rel="stylesheet" type="text/css"
          href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
-->
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css" />
    
    <!-- [[! Ghost outputs important style and meta data with this tag ]] -->
        <link rel="canonical" href="/" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/page2/" />

    <meta property="og:site_name" content="Alan Yeh" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Alan Yeh" />
    <meta property="og:description" content="写写代码，想想东西，程序员的世界可以就这么简单。" />
    <meta property="og:url" content="/" />
    <meta property="og:image" content="/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Alan Yeh" />
    <meta name="twitter:description" content="写写代码，想想东西，程序员的世界可以就这么简单。" />
    <meta name="twitter:url" content="/" />
    <meta name="twitter:image:src" content="/assets/images/cover1.jpg" />

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="Alan Yeh" href="/rss.xml" />
    
    
    	<!-- Baidu Analytics Tracking code -->
	<script>
		var _hmt = _hmt || [];
		(function() {
			var hm = document.createElement("script");
			hm.src = "//hm.baidu.com/hm.js?32c2c629fa6b497aa2a25454093d6dd9";
			var s = document.getElementsByTagName("script")[0]; 
			s.parentNode.insertBefore(hm, s);
		})();
	</script>
    
    
</head>
<body class="home-template nav-closed">

    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
	    	
	    <li class="nav-Home" role="presentation"><a href="/">Home</a></li>
			
	    <li class="nav-About" role="presentation"><a href="/about">About</a></li>
			
	    <li class="nav-Objective-C" role="presentation"><a href="/tag/Objective-C">Objective-C</a></li>
			
	    <li class="nav-Java-Web" role="presentation"><a href="/tag/Java-Web">Java-Web</a></li>
			
	    <li class="nav-Linux" role="presentation"><a href="/tag/Linux">Linux</a></li>
			
	    <li class="nav-Git" role="presentation"><a href="/tag/Git">Git</a></li>
			
	    <li class="nav-Jekyll" role="presentation"><a href="/tag/Jekyll">Jekyll</a></li>
		
    </ul>
    <a class="subscribe-button icon-feed" href="/rss.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>

    <div class="site-wrapper">

        <!-- [[! Everything else gets inserted here ]] -->
        <!-- < default -->

<!-- The comment above "< default" means - insert everything in this file into -->
<!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

	
		
		
			
				
				
	


<header class="main-header post-head " style="background-image: url(/assets/images/cover7.jpg) ">
    <nav class="main-nav  clearfix">
        <a class="blog-logo" href="/"><img src="/assets/images/logo.png" alt="Blog Logo" /></a>
        <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-fiction">

        <header class="post-header">
            <h1 class="post-title">PSPromise Promise的简易实现</h1>
            <section class="post-meta">
            <!-- <a href='/'>Alan Yeh</a> -->
            <time class="post-date" datetime="2016-03-05">05 Mar 2016</time>
                <!-- [[tags prefix=" on "]] -->
                 
                on 
                
                    
                       <a href='/tag/Objective-C'>Objective-C</a>
                       
                
                
            </section>
        </header>

        <section class="post-content">
            
            <p>　　<a href="https://github.com/Poi-Son/PSPromise">PSPromise</a>是Promise的简易实现。遵循CommonJS的Promise/A接口标准，同时实现了一些扩展接口，使PSPromise更实用。</p>

<p>　　近期看到一个很有意思的框架<a href="https://github.com/mxcl/PromiseKit">PromiseKit</a>。看到PromiseKit的源码之后，对它的编写方式感到神奇，刚开始完全看不懂在写什么东西，而且代码是怎么运行的也完全没个头绪。仔细分析了大半天之后，感叹大神写代码的确与众不同。由于个人的一些“不良嗜好”，决定写一个简易版的Promise，同时实践一下这种新型语法。</p>

<h3>简介</h3>

<hr>

<h4>什么是Promise</h4>

<p>　　Promise，承诺，在开发中的意思是，我承诺我去做一些事情，但不一定现在就去做，而是在将来满足一些条件之后才执行。Promise刚开始出现在前端开发领域中，主要用来解决JS开发中的异步问题。在使用Promise之前，异步的处理使用最多的就是用回调这种形式，比如：</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">doSomethingAsync</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">error</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">){</span>
        <span class="p">...</span><span class="c1">//处理error</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">...</span><span class="c1">//处理result</span>
    <span class="p">}</span>
<span class="p">})</span>
</code></pre></div>
<p>　　在Objective-C中，这类代码也是非常常见的。例如著名的AFNetworking中，访问网络就是使用block回调。</p>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c">    <span class="p">[</span><span class="n">client</span> <span class="nl">getPath</span><span class="p">:</span><span class="s">@&quot;xxx&quot;</span>
         <span class="nl">parameters</span><span class="p">:</span><span class="n">params</span>
            <span class="nl">success</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">AFHTTPRequestOperation</span> <span class="o">*</span><span class="n">operation</span><span class="p">,</span> <span class="kt">id</span> <span class="n">responseObject</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//处理success</span>
            <span class="p">}</span>
            <span class="nl">failure</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">AFHTTPRequestOperation</span> <span class="o">*</span><span class="n">operation</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//处理failure</span>
            <span class="p">}]</span>
</code></pre></div>
<p>　　这种书写方式，可以很容易解决对异步操作的处理。但是这样的写法，很容易引起回调金字塔的情况。Promise则对异步处理和处理方法都做了规范和抽象，还给了开发者在异步代码中使用return和throw的能力。这也是Promise存在的真正意义。</p>

<h4>使用Promise</h4>

<p>　　来看一个常见的业务场景，获取联系人需要先访问一次服务器(登录或一些必要的操作)，然后再访问一次服务器才能真正获取到有效数据，然后再进行一系列的错误处理，代码冗余复杂。</p>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">getContactSuccess:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="bp">NSArray</span> <span class="o">*</span><span class="p">))</span><span class="nv">success</span> <span class="nf">failure:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="bp">NSError</span> <span class="o">*</span><span class="p">))</span><span class="nv">failure</span><span class="p">{</span>
    <span class="p">[</span><span class="n">client</span> <span class="nl">getPath</span><span class="p">:</span><span class="s">@&quot;xxx&quot;</span>
         <span class="nl">parameters</span><span class="p">:</span><span class="n">params</span>
            <span class="nl">success</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">AFHTTPRequestOperation</span> <span class="o">*</span><span class="n">operation</span><span class="p">,</span> <span class="kt">id</span> <span class="n">responseObject</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//处理Json序列化</span>
                <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>
                <span class="bp">NSDictionary</span> <span class="o">*</span><span class="n">dic</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSJSONSerialization</span> <span class="nl">JSONObjectWithData</span><span class="p">:</span><span class="n">responseObject</span> <span class="nl">options</span><span class="p">:</span><span class="n">kNilOptions</span> <span class="nl">error</span><span class="p">:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">failure</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">([</span><span class="n">dic</span><span class="p">[</span><span class="s">@&quot;status&quot;</span><span class="p">]</span> <span class="n">intValue</span><span class="p">]</span> <span class="o">==</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">//需要依赖上一次网络访问的结果，进行下一步访问</span>
                    <span class="p">[</span><span class="n">client</span> <span class="nl">getPath</span><span class="p">:</span><span class="s">@&quot;yyy&quot;</span>
                         <span class="nl">parameters</span><span class="p">:</span><span class="n">params</span>
                            <span class="nl">success</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">AFHTTPRequestOperation</span> <span class="o">*</span><span class="n">operation</span><span class="p">,</span> <span class="kt">id</span> <span class="n">responseObject</span><span class="p">)</span> <span class="p">{</span>
                                <span class="c1">//处理Json</span>
                                <span class="c1">//处理业务</span>
                                <span class="c1">//组装实体</span>
                                <span class="c1">//....</span>
                                <span class="n">success</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
                            <span class="p">}</span>
                            <span class="nl">failure</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">AFHTTPRequestOperation</span> <span class="o">*</span><span class="n">operation</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                                <span class="c1">//处理网络错误</span>
                                <span class="n">failure</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
                            <span class="p">}];</span>
                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                    <span class="c1">//处理错误</span>
                    <span class="n">failure</span><span class="p">(</span><span class="cm">/*返回错误*/</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nl">failure</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">AFHTTPRequestOperation</span> <span class="o">*</span><span class="n">operation</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//处理网络错误</span>
                <span class="n">failure</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
            <span class="p">}];</span>
<span class="p">}</span>
</code></pre></div>
<p>　　使用Promise改造一下</p>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="c1">//网络访问与业务分离</span>
<span class="p">-</span> <span class="p">(</span><span class="n">PSPromise</span> <span class="o">*</span><span class="p">)</span><span class="nf">get:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">getPath</span> <span class="nf">withParam:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">param</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">PSPromiseWithResolve</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">PSResolve</span> <span class="n">resolve</span><span class="p">){</span>
        <span class="p">[</span><span class="n">client</span> <span class="nl">getPath</span><span class="p">:</span><span class="s">@&quot;xxx&quot;</span>
             <span class="nl">parameters</span><span class="p">:</span><span class="n">param</span>
                <span class="nl">success</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">AFHTTPRequestOperation</span> <span class="o">*</span><span class="n">operation</span><span class="p">,</span> <span class="kt">id</span> <span class="n">responseObject</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">resolve</span><span class="p">(</span><span class="n">responseObject</span><span class="p">);</span>
              <span class="p">}</span> <span class="nl">failure</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">AFHTTPRequestOperation</span> <span class="o">*</span><span class="n">operation</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">resolve</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
         <span class="p">}];</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="c1">//Json序列化与业务分离</span>
<span class="p">-</span> <span class="p">(</span><span class="n">PSPromise</span> <span class="o">*</span><span class="p">)</span><span class="nf">parseJson:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">responseObject</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">PSPromiseWith</span><span class="p">(</span><span class="o">^</span><span class="kt">id</span><span class="p">{</span>
        <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>
        <span class="bp">NSDictionary</span> <span class="o">*</span><span class="n">json</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSJSONSerialization</span> <span class="nl">JSONObjectWithData</span><span class="p">:</span><span class="n">responseObject</span> <span class="nl">options</span><span class="p">:</span><span class="n">kNilOptions</span> <span class="nl">error</span><span class="p">:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="k">return</span> <span class="n">json</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="n">PSPromise</span> <span class="o">*</span><span class="p">)</span><span class="nf">getContacts</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">PSPromiseWith</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
        <span class="c1">//第一次访问网络</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">get</span><span class="p">:</span><span class="s">@&quot;xxx&quot;</span> <span class="nl">withParam</span><span class="p">:</span><span class="n">params</span><span class="p">];</span>
    <span class="p">}).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">responseObject</span><span class="p">){</span>
        <span class="c1">//处理Json序列化</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">parseJson</span><span class="p">:</span><span class="n">responseObject</span><span class="p">];</span>
    <span class="p">}).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="bp">NSDictionary</span> <span class="o">*</span><span class="n">json</span><span class="p">){</span>
        <span class="c1">//第二次访问网络</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">get</span><span class="p">:</span><span class="s">@&quot;yyy&quot;</span> <span class="nl">withParam</span><span class="p">:</span><span class="n">params</span><span class="p">];</span>
    <span class="p">}).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">responseObject</span><span class="p">){</span>
        <span class="c1">//再次处理Json序列化</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">parseJson</span><span class="p">:</span><span class="n">responseObject</span><span class="p">];</span>
    <span class="p">}).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="bp">NSDictionary</span><span class="o">*</span> <span class="n">result</span><span class="p">){</span>
        <span class="c1">//处理业务正确性</span>
        <span class="k">if</span> <span class="p">([</span><span class="n">result</span><span class="p">[</span><span class="s">@&quot;status&quot;</span><span class="p">]</span> <span class="n">intValue</span><span class="p">]</span> <span class="o">==</span> <span class="mi">200</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="k">return</span> <span class="n">error</span><span class="p">;</span><span class="cm">/*构建一个NSError对象返回*/</span>
        <span class="p">}</span>
    <span class="p">}).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="bp">NSDictionary</span><span class="o">*</span> <span class="n">result</span><span class="p">){</span>
        <span class="c1">//组装实体</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<p>　　可以看到，通过Promise的改造，原本层层嵌套代码，变得有序、清晰起来。什么？你问哪里处理错误？放心，通过Promise，可以进行统一的错误处理。</p>

<h3>Promise状态</h3>

<hr>

<p>　　每个Promise都只会被成功或失败一次，并且这个状态不会被改变。</p>

<p>　　一个Promise必须处于以下几个状态之一：</p>

<ul>
<li>PSPromiseStatePending(Pending): 操作正在执行中(等待执行)，可以转换到Fulfilled或Rejected状态。</li>
<li>PSPromiseStateFulfilled(Fulfilled): 操作执行成功，且状态不可改变</li>
<li>PSPromiseStateRejected(Rejected): 操作执行失败，且状态不可改变</li>
</ul>

<p>　　有些文章或Promise实现会出现第4种状态Settled，代表操作已结束，可以认为Settled = Fulfilled &amp; Rejected。他本身并不是一种状态，因为非Pending就是Settled，只是为了说的方便而引入Settled这个说法。</p>

<p>　　Promise处于Pending状态时，其value一定为nil；处于Fulfilled状态时，其value为处理结果，可能为nil；处于Rejected状态时，其value一定为NSError对象，用于描述Promise被拒绝原因。</p>

<h3>CommonJS Promise/A</h3>

<hr>

<p>　　PSPromise支持标准的CommonJS Promise/A语法。由于语言的特殊，对其中部份Api进行小量改造。</p>

<h4>构造函数</h4>

<p>　　由于PSPromise使用链式调用语法，抛弃OC的传统构造函数，使用C构造PSPromise对象更有利于书写方便。PSPromise有以下构造函数：</p>

<h5><code>PSPromise *PSPromiseWithResolve(void (^)(PSResolve resolve))</code></h5>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="n">PSPromise</span> <span class="o">*</span><span class="n">promise</span> <span class="o">=</span> <span class="n">PSPromiseWithResolve</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">PSResolve</span> <span class="n">resolve</span><span class="p">){</span>
    <span class="n">resolve</span><span class="p">(</span><span class="s">@&quot;aaa&quot;</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
<p>　　PSPromiseWithResolve提供了一个回调PSResolve，使用<code>resolve(value)</code>返回结果。</p>

<h5><code>PSPromise *PSPromiseWith(id value)</code></h5>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="n">PSPromise</span> <span class="o">*</span><span class="n">promise</span> <span class="o">=</span> <span class="n">PSPromiseWith</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="k">return</span> <span class="s">@&quot;aaa&quot;</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div>
<p>　　PSPromiseWith创建Promise对象，参数value可以为以下类型：</p>

<ul>
<li>block，创建一个Pending状态的Promise并同步执行block</li>
<li>Promise，直接返回该Promise对象</li>
<li>数组，返回Promise.all封装的Promise</li>
<li>NSError，返回一个Rejected状态的Promise</li>
<li>其它对象（包括nil），返回一个Fulfilled状态的Promise</li>
</ul>

<h5><code>PSPromise *PSPromiseAsyncWith(id value)</code></h5>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="n">PSPromise</span> <span class="o">*</span><span class="n">promise</span> <span class="o">=</span> <span class="n">PSPromiseAsyncWith</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="c1">//异步执行</span>
    <span class="k">return</span> <span class="p">[[</span><span class="bp">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithContentsOfURL</span><span class="p">:[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;https://www.baidu.com&quot;</span><span class="p">]</span> <span class="nl">encoding</span><span class="p">:</span><span class="n">NSUTF8StringEncoding</span> <span class="nl">error</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
<span class="p">});</span>
</code></pre></div>
<p>　　PSPromiseAsyncWith创建异步执行的Promise</p>

<h4>then</h4>

<p>　　then语法用于处理正确(Fulfilled)的Promise结果。在CommonJS Promise/A的语法中，then应该支持2个回调函数，第一个回调函数处理Fulfilled的结果，第二个回调函数处理Rejected的结果。为了减少其书写上的复杂性，PSPromise的then语法仅支持1个block，用于处理正确(Fulfilled)结果。</p>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="n">promise</span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">result</span><span class="p">){</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">result</span> <span class="nl">stringByAppendingString</span><span class="p">:</span><span class="s">@&quot;bbb&quot;</span><span class="p">];</span>
<span class="p">});</span>
</code></pre></div>
<p>　　then语法必须接受一个不为空的block类型的参数。then语法中的block支持无参或1个参数。</p>

<p>　　如果block：</p>

<ul>
<li>返回普通OC对象(包括nil)，当前Promise状态变更成Fulfilled，vlaue被赋值为返回值。</li>
<li>没有返回值，当前Promise状态变更成Fulfilled，value被赋值为nil。</li>
<li>返回NSError对象，当前Promise状态变更成Rejected，value被赋值为NSError对象。</li>
<li>返回Promise对象，当前Promise对象抛弃，当前Promise链之后的Promise被托管至返回的Promise对象。</li>
<li>抛出错误(仅捕捉NSError错误，不捕捉其它对象)，当前Promise状态变更成Rejected，value被赋值为NSError对象。</li>
</ul>

<h4>catch</h4>

<p>　　catch语法用于处理被拒绝(Rejected)的Promise对象的结果。</p>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="nl">PSPromiseWithResolve</span><span class="p">:(</span><span class="o">^</span><span class="p">(</span><span class="n">PSResolve</span> <span class="n">resolve</span><span class="p">){</span>
    <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="p">...;</span>
    <span class="n">resolve</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="c1">//由于Promise为Rejected，因此then不执行</span>
<span class="p">}).</span><span class="n">catch</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">){</span>
    <span class="c1">//处理Promise为Rejected</span>
<span class="p">}).</span><span class="n">catch</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">){</span>
    <span class="c1">//由于当前的catch之前，Rejected的Promise已经被处理了，所以这个catch不执行</span>
<span class="p">});</span>
</code></pre></div>
<p>　　catch语法必须接受一个不为空的block类型参数。catch语法中的block支持无参或1个NSError参数。catch专门用于处理被拒绝(Rejected)的Promise，then专门处理正确(Fulfilled)的Promise。</p>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="nl">PSPromiseWithResolve</span><span class="p">:(</span><span class="o">^</span><span class="p">(</span><span class="n">PSResolve</span> <span class="n">resolve</span><span class="p">){</span>
    <span class="n">resolve</span><span class="p">(</span><span class="s">@&quot;aaa&quot;</span><span class="p">);</span>
<span class="p">}).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span><span class="c1">//业务产生了一个错误</span>
    <span class="k">@throw</span> <span class="n">error</span><span class="p">;</span><span class="c1">//直接抛出异常可以被下一个catch捕捉到</span>
    <span class="c1">//return error;//直接返回也可以被下一个catch捕捉到</span>
<span class="p">}).</span><span class="n">catch</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">){</span>
    <span class="c1">//可以处理catch之前错误</span>
<span class="p">});</span>
</code></pre></div>
<h4>all</h4>

<p>　　all语法是静态类函数，接受一个Promise数组，并返回一个包装后的Promise对象，称之为A。A的状态改变有两个条件：</p>

<ol>
<li>当数组中所有的promise对象变成成功状态(Fulfilled)，这个包装后的A才会把自己变成成功状态。A会等待最慢的那个promise对象变成成功态后才把自己变成成功态，并将promise数组的结果封装成它们的结果数据。</li>
<li>只要其中一个promise对象变成失败状态(Rejected)，这个包装后的A就变成失败状态，并且第一个rejected promise传递过来的NSError值会传递给A后面的catch。</li>
</ol>

<p>　　因此，all语法可以理解为判断语句『且』，当所有条件都成功时它才成功，当有一个条件失败时，它就是失败。</p>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="n">PSPromise</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="n">PSPromiseWith</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="k">return</span> <span class="s">@&quot;aa&quot;</span><span class="p">;</span>
<span class="p">});</span>
<span class="n">PSPromise</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">PSPromiseWith</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="k">@throw</span> <span class="n">error</span><span class="p">;</span>
<span class="p">});</span>
<span class="n">PSPromise</span> <span class="o">*</span><span class="n">p3</span> <span class="o">=</span> <span class="n">PSPromiseWith</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="k">return</span> <span class="s">@&quot;cc&quot;</span><span class="p">;</span>
<span class="p">});</span>

<span class="n">PSPromise</span> <span class="o">*</span><span class="n">pAll</span> <span class="o">=</span> <span class="n">PSPromise</span><span class="p">.</span><span class="n">all</span><span class="p">(</span><span class="l">@[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="l">]</span><span class="p">).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="bp">NSArray</span> <span class="o">*</span><span class="n">result</span><span class="p">){</span>
    <span class="c1">//then语法不会执行，因为p2抛出异常了</span>
<span class="p">}).</span><span class="n">catch</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">){</span>
    <span class="c1">//catch会执行，捕捉到p2所抛出来的错误</span>
<span class="p">});</span>

<span class="cm">/************************************************************/</span>

<span class="n">PSPromise</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="n">PSPromiseWith</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="k">return</span> <span class="s">@&quot;aa&quot;</span><span class="p">;</span>
<span class="p">});</span>
<span class="n">PSPromise</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">PSPromiseWith</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="k">return</span> <span class="s">@&quot;bb&quot;</span><span class="p">;</span>
<span class="p">});</span>
<span class="n">PSPromise</span> <span class="o">*</span><span class="n">p3</span> <span class="o">=</span> <span class="n">PSPromiseWith</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="k">return</span> <span class="s">@&quot;cc&quot;</span><span class="p">;</span>
<span class="p">});</span>

<span class="n">PSPromise</span> <span class="o">*</span><span class="n">pAll</span> <span class="o">=</span> <span class="n">PSPromise</span><span class="p">.</span><span class="n">all</span><span class="p">(</span><span class="l">@[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="l">]</span><span class="p">).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="bp">NSArray</span> <span class="o">*</span><span class="n">result</span><span class="p">){</span>
    <span class="c1">//then会执行，result = @[@&quot;aa&quot;, @&quot;bb&quot;, @&quot;cc&quot;];</span>
<span class="p">}).</span><span class="n">catch</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">){</span>
    <span class="c1">//catch不会执行</span>
<span class="p">});</span>
</code></pre></div>
<h4>race</h4>

<p>　　race语法是静态类函数，接受一个Promise数组，并返回一个包装后的Promise对象，称之为R。R的状态改变有两个条件:</p>

<ol>
<li>当数组中所有的promise对象变成失败状态(Rejected)，这个包装后的R才会把自己变成失败状态。R会等待最慢的那个promise对象变成失败状态后才把自己变成失败态，并将promise数组所有NSError封装成一个NSError传递给后面的catch。</li>
<li>只要其中一个promise对象变成成功状态(Fulfilled)，这个包装后的R就变成成功状态，并且将第一个fulfilled promise的结果值传给R后面的then。</li>
</ol>

<p>　　因此，race语法可以理解为判断语句的『或』，当所有条件都失败时它才失败，当其中一个条件成功时，它成功。</p>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="n">PSPromise</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="n">PSPromiseWith</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="k">return</span> <span class="s">@&quot;aa&quot;</span><span class="p">;</span>
<span class="p">});</span>
<span class="n">PSPromise</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">PSPromiseWith</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="k">@throw</span> <span class="n">error</span><span class="p">;</span>
<span class="p">});</span>
<span class="n">PSPromise</span> <span class="o">*</span><span class="n">p3</span> <span class="o">=</span> <span class="nl">PSPromiseWithResolve</span><span class="p">:(</span><span class="o">^</span><span class="p">(</span><span class="n">PSResolve</span> <span class="n">resolve</span><span class="p">){</span>
    <span class="n">resolve</span><span class="p">(</span><span class="s">@&quot;cc&quot;</span><span class="p">);</span>
<span class="p">});</span>

<span class="n">PSPromise</span> <span class="o">*</span><span class="n">pRace</span> <span class="o">=</span> <span class="n">PSPromise</span><span class="p">.</span><span class="n">race</span><span class="p">(</span><span class="l">@[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="l">]</span><span class="p">).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">result</span><span class="p">){</span>
    <span class="c1">//then会执行，result = @&quot;aa&quot;</span>
<span class="p">}).</span><span class="n">catch</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">){</span>
    <span class="c1">//catch不会执行，因为p1是成功状态，代表race是成功的</span>
<span class="p">});</span>

<span class="cm">/************************************************************/</span>

<span class="n">PSPromise</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="n">PSPromiseWith</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="k">@throw</span> <span class="n">error</span><span class="p">;</span>
<span class="p">});</span>
<span class="n">PSPromise</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="nl">PSPromiseWithResolve</span><span class="p">:(</span><span class="o">^</span><span class="p">(</span><span class="n">PSResolve</span> <span class="n">resolve</span><span class="p">){</span>
    <span class="n">resolve</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">});</span>
<span class="n">PSPromise</span> <span class="o">*</span><span class="n">p3</span> <span class="o">=</span> <span class="n">PSPromiseWith</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">});</span>

<span class="n">PSPromise</span> <span class="o">*</span><span class="n">pRace</span> <span class="o">=</span> <span class="n">PSPromise</span><span class="p">.</span><span class="n">race</span><span class="p">(</span><span class="l">@[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="l">]</span><span class="p">).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">result</span><span class="p">){</span>
    <span class="c1">//then不会执行，因为race中所有的promise都失败了</span>
<span class="p">}).</span><span class="n">catch</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">){</span>
    <span class="c1">//catch会执行，并且NSArray&lt;NSError *&gt; *errors = error.userInfo[PSPromiseInternalErrorsKey]可以获取所有错误</span>
<span class="p">});</span>
</code></pre></div>
<h3>扩展语法</h3>

<hr>

<p>　　CommonJS Promise/A中的语法较少，考虑到OC实际运用时的便捷性，PSPromise增加了一些实用方法。</p>

<h4>always</h4>

<p>　　always语法与then、catch语法类似，与then只处理正确逻辑、catch只处理错误逻辑不同的是，always总是会执行。</p>

<h4>thenAsync</h4>

<p>　　thenAsync与then语法使用一致，但是该方法是在<code>dispatch_get_global_queue(0, 0)</code>线程中执行，而then方法总是在主线程中执行。</p>

<h4>thenOn</h4>

<p>　　thenOn与then语法使用一致，但参数要求用户传递一个指定线程，则block在该线程下执行。</p>

<h4>thenPromise</h4>

<p>　　thenPromise是then语法的一个变种，通过回调来返回结果</p>

<h4>catchAsync</h4>

<p>　　catchAsync语法与catch语法使用方法一致，但是该方法是在<code>dispatch_get_global_queue(0, 0)</code>线程中执行，而catch方法总是在主线程中执行。</p>

<h4>catchOn</h4>

<p>　　catchOn与catch语法使用方法一致，但参数要求用户传递一个指定线程，则block在该线程下执行。</p>

<h3>其它</h3>

<hr>

<ol>
<li><p>关于多线程：PSPromise的方法中，如果没有Async、On这类标识，则block会在主线程中执行，否则会在<code>dispatch_get_global_queue(0, 0)</code>或用户指定的线程中执行，添加这些方法主要方便用户在各个线程中切换。</p></li>
<li><p>关于泛型：PSPromise其实不支持泛型。但是为什么又引用泛型，目的是在于当Promise作为函数结果返回时，标识一下当前Promise将会返回什么样的数据，当继续then的时候，可以知道then所获取的结果是一个怎么样的类型。</p></li>
</ol>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->

            
            <figure class="author-image">
                <a class="img" href="/about" style="background-image: url(/assets/images/avatar.jpg)"><span class="hidden">Alan Yeh's Picture</span></a>
            </figure>
            

            <section class="author">
                <h4><a href="/about">Alan Yeh</a></h4>
                
                
                    <p> 简单技术控，喜欢接触各类技术</p>
                
                <div class="author-meta">
                    <span class="author-location icon-location"> GZ, China</span> 
                    <span class="author-link icon-link"><a href="http://yerl.cn"> http://yerl.cn</a></span> 
                </div>
            </section>

            <!-- /author  -->
            
            <!-- Add Comments -->
            
            
            
                
<!-- disqus -->
<div id="disqus_thread"></div>
<script>
	var disqus_config = function () {
		this.page.url = 'http://yerl.cn/blog/pspromise'; // Replace PAGE_URL with your page's canonical URL variable
		this.page.identifier = '/blog/pspromise'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
	};

	(function() { // DON'T EDIT BELOW THIS LINE
		var d = document, s = d.createElement('script');
		s.src = '//yerll.disqus.com/embed.js';
		s.setAttribute('data-timestamp', +new Date());
		(d.head || d.body).appendChild(s);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<!-- disqus -->
            
            
        </footer>

    </article>

</main>

<aside class="read-next">
    
    
    	
			
				
				
					
						
						
			
		

    <!-- [[! next_post ]] -->
    <a class="read-next-story " style="background-image: url(/assets/images/cover7.jpg)" href="/blog/promise-practise">
        <section class="post">
            <h2>PSPromise在项目中实践</h2>
            <p>　　经过上一篇博客，对于[PSPromise](/blog/PSPromise)的介绍，对Promise的相关语法大概了解了。这篇博客主要介绍PSPromise在项目中如何实践，如何优雅地写代码。代码已上传至[GitHub](https://github.com/Poi-Son/Example...</p>
        </section>
    </a>
        
    <!-- [[! /next_post ]] -->
    
    
    	
			
				
				
					
				
					
				
					
				
					
				
					
				
					
						
						
			
		
		
    <!-- [[! prev_post ]] -->
    <a class="read-next-story prev " style="background-image: url(/assets/images/cover6.jpg)" href="/blog/use-travis-ci-generate-sites">
        <section class="post">
            <h2>利用Travis CI生成网页，支持Tags/Categorys</h2>
            <p>　　现在大多使用Jekyll，并且支持Tags/Categorys的博客，都是将所有博客标题链接放到同一个页面中。博客量少的时候，弊端并不明显；但是博客量大的时候，同一个页面下的博客标题太多，就会给人一种目不暇接的感觉。大多数人第一时间想到就是利用分页。

　　想要将Tags/Category...</p>
        </section>
    </a>
    <!-- [[! /prev_post ]] -->
    
</aside>

<!-- /post -->


        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/">Alan Yeh</a> &copy; 2016</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/Poi-Son/Pasper">Pasper</a></section>
        </footer>
    </div>
    <!-- [[! Ghost outputs important scripts and data with this tag ]] -->
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <!-- [[! The main JavaScript file for Casper ]] -->
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/assets/js/index.js"></script>
</body>
</html>
